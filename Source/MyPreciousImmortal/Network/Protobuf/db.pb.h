// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_2eproto;
namespace Proto {
class Card;
class CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class CardTeam;
class CardTeamDefaultTypeInternal;
extern CardTeamDefaultTypeInternal _CardTeam_default_instance_;
class DBAccount;
class DBAccountDefaultTypeInternal;
extern DBAccountDefaultTypeInternal _DBAccount_default_instance_;
class DBWorldData;
class DBWorldDataDefaultTypeInternal;
extern DBWorldDataDefaultTypeInternal _DBWorldData_default_instance_;
class DropRecord;
class DropRecordDefaultTypeInternal;
extern DropRecordDefaultTypeInternal _DropRecord_default_instance_;
class Equipment;
class EquipmentDefaultTypeInternal;
extern EquipmentDefaultTypeInternal _Equipment_default_instance_;
class Item;
class ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemBase;
class ItemBaseDefaultTypeInternal;
extern ItemBaseDefaultTypeInternal _ItemBase_default_instance_;
class LastWorld;
class LastWorldDefaultTypeInternal;
extern LastWorldDefaultTypeInternal _LastWorld_default_instance_;
class NPC;
class NPCDefaultTypeInternal;
extern NPCDefaultTypeInternal _NPC_default_instance_;
class OBJ;
class OBJDefaultTypeInternal;
extern OBJDefaultTypeInternal _OBJ_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerBase;
class PlayerBaseDefaultTypeInternal;
extern PlayerBaseDefaultTypeInternal _PlayerBase_default_instance_;
class PlayerCard;
class PlayerCardDefaultTypeInternal;
extern PlayerCardDefaultTypeInternal _PlayerCard_default_instance_;
class PlayerCharacter;
class PlayerCharacterDefaultTypeInternal;
extern PlayerCharacterDefaultTypeInternal _PlayerCharacter_default_instance_;
class PlayerItem;
class PlayerItemDefaultTypeInternal;
extern PlayerItemDefaultTypeInternal _PlayerItem_default_instance_;
class PlayerMisc;
class PlayerMiscDefaultTypeInternal;
extern PlayerMiscDefaultTypeInternal _PlayerMisc_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Skill;
class SkillDefaultTypeInternal;
extern SkillDefaultTypeInternal _Skill_default_instance_;
class Team;
class TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
class Vector3;
class Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace Proto
PROTOBUF_NAMESPACE_OPEN
template<> ::Proto::Card* Arena::CreateMaybeMessage<::Proto::Card>(Arena*);
template<> ::Proto::CardTeam* Arena::CreateMaybeMessage<::Proto::CardTeam>(Arena*);
template<> ::Proto::DBAccount* Arena::CreateMaybeMessage<::Proto::DBAccount>(Arena*);
template<> ::Proto::DBWorldData* Arena::CreateMaybeMessage<::Proto::DBWorldData>(Arena*);
template<> ::Proto::DropRecord* Arena::CreateMaybeMessage<::Proto::DropRecord>(Arena*);
template<> ::Proto::Equipment* Arena::CreateMaybeMessage<::Proto::Equipment>(Arena*);
template<> ::Proto::Item* Arena::CreateMaybeMessage<::Proto::Item>(Arena*);
template<> ::Proto::ItemBase* Arena::CreateMaybeMessage<::Proto::ItemBase>(Arena*);
template<> ::Proto::LastWorld* Arena::CreateMaybeMessage<::Proto::LastWorld>(Arena*);
template<> ::Proto::NPC* Arena::CreateMaybeMessage<::Proto::NPC>(Arena*);
template<> ::Proto::OBJ* Arena::CreateMaybeMessage<::Proto::OBJ>(Arena*);
template<> ::Proto::Player* Arena::CreateMaybeMessage<::Proto::Player>(Arena*);
template<> ::Proto::PlayerBase* Arena::CreateMaybeMessage<::Proto::PlayerBase>(Arena*);
template<> ::Proto::PlayerCard* Arena::CreateMaybeMessage<::Proto::PlayerCard>(Arena*);
template<> ::Proto::PlayerCharacter* Arena::CreateMaybeMessage<::Proto::PlayerCharacter>(Arena*);
template<> ::Proto::PlayerItem* Arena::CreateMaybeMessage<::Proto::PlayerItem>(Arena*);
template<> ::Proto::PlayerMisc* Arena::CreateMaybeMessage<::Proto::PlayerMisc>(Arena*);
template<> ::Proto::Position* Arena::CreateMaybeMessage<::Proto::Position>(Arena*);
template<> ::Proto::Skill* Arena::CreateMaybeMessage<::Proto::Skill>(Arena*);
template<> ::Proto::Team* Arena::CreateMaybeMessage<::Proto::Team>(Arena*);
template<> ::Proto::Vector3* Arena::CreateMaybeMessage<::Proto::Vector3>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Proto {

enum Card_CardCareerType : int {
  Card_CardCareerType_none = 0,
  Card_CardCareerType_ghost = 1,
  Card_CardCareerType_king = 2,
  Card_CardCareerType_god = 3,
  Card_CardCareerType_should = 4,
  Card_CardCareerType_Master = 5,
  Card_CardCareerType_Card_CardCareerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Card_CardCareerType_Card_CardCareerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Card_CardCareerType_IsValid(int value);
constexpr Card_CardCareerType Card_CardCareerType_CardCareerType_MIN = Card_CardCareerType_none;
constexpr Card_CardCareerType Card_CardCareerType_CardCareerType_MAX = Card_CardCareerType_Master;
constexpr int Card_CardCareerType_CardCareerType_ARRAYSIZE = Card_CardCareerType_CardCareerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Card_CardCareerType_descriptor();
template<typename T>
inline const std::string& Card_CardCareerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Card_CardCareerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Card_CardCareerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Card_CardCareerType_descriptor(), enum_t_value);
}
inline bool Card_CardCareerType_Parse(
    const std::string& name, Card_CardCareerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Card_CardCareerType>(
    Card_CardCareerType_descriptor(), name, value);
}
enum Card_CardCultivateState : int {
  Card_CardCultivateState_CLEVEL = 0,
  Card_CardCultivateState_CSTAR = 1,
  Card_CardCultivateState_CQLT = 2,
  Card_CardCultivateState_Card_CardCultivateState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Card_CardCultivateState_Card_CardCultivateState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Card_CardCultivateState_IsValid(int value);
constexpr Card_CardCultivateState Card_CardCultivateState_CardCultivateState_MIN = Card_CardCultivateState_CLEVEL;
constexpr Card_CardCultivateState Card_CardCultivateState_CardCultivateState_MAX = Card_CardCultivateState_CQLT;
constexpr int Card_CardCultivateState_CardCultivateState_ARRAYSIZE = Card_CardCultivateState_CardCultivateState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Card_CardCultivateState_descriptor();
template<typename T>
inline const std::string& Card_CardCultivateState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Card_CardCultivateState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Card_CardCultivateState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Card_CardCultivateState_descriptor(), enum_t_value);
}
inline bool Card_CardCultivateState_Parse(
    const std::string& name, Card_CardCultivateState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Card_CardCultivateState>(
    Card_CardCultivateState_descriptor(), name, value);
}
enum Team_TeamType : int {
  Team_TeamType_Normal = 0,
  Team_TeamType_Team_TeamType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Team_TeamType_Team_TeamType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Team_TeamType_IsValid(int value);
constexpr Team_TeamType Team_TeamType_TeamType_MIN = Team_TeamType_Normal;
constexpr Team_TeamType Team_TeamType_TeamType_MAX = Team_TeamType_Normal;
constexpr int Team_TeamType_TeamType_ARRAYSIZE = Team_TeamType_TeamType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Team_TeamType_descriptor();
template<typename T>
inline const std::string& Team_TeamType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Team_TeamType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Team_TeamType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Team_TeamType_descriptor(), enum_t_value);
}
inline bool Team_TeamType_Parse(
    const std::string& name, Team_TeamType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Team_TeamType>(
    Team_TeamType_descriptor(), name, value);
}
enum Gender : int {
  none = 0,
  male = 1,
  female = 2,
  Gender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Gender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Gender_IsValid(int value);
constexpr Gender Gender_MIN = none;
constexpr Gender Gender_MAX = female;
constexpr int Gender_ARRAYSIZE = Gender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gender_descriptor();
template<typename T>
inline const std::string& Gender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gender_descriptor(), enum_t_value);
}
inline bool Gender_Parse(
    const std::string& name, Gender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gender>(
    Gender_descriptor(), name, value);
}
// ===================================================================

class Vector3 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector3* New() const final {
    return CreateMaybeMessage<Vector3>(nullptr);
  }

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Vector3";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Proto.Vector3)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class ItemBase :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.ItemBase) */ {
 public:
  ItemBase();
  virtual ~ItemBase();

  ItemBase(const ItemBase& from);
  ItemBase(ItemBase&& from) noexcept
    : ItemBase() {
    *this = ::std::move(from);
  }

  inline ItemBase& operator=(const ItemBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemBase& operator=(ItemBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ItemBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemBase* internal_default_instance() {
    return reinterpret_cast<const ItemBase*>(
               &_ItemBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemBase& a, ItemBase& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemBase* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ItemBase* New() const final {
    return CreateMaybeMessage<ItemBase>(nullptr);
  }

  ItemBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ItemBase>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ItemBase& from);
  void MergeFrom(const ItemBase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemBase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.ItemBase";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 num = 2;
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.ItemBase)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Item :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Item) */ {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Item* New() const final {
    return CreateMaybeMessage<Item>(nullptr);
  }

  Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Item";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemBaseFieldNumber = 2,
    kSnFieldNumber = 1,
  };
  // .Proto.ItemBase item_base = 2;
  bool has_item_base() const;
  void clear_item_base();
  const ::Proto::ItemBase& item_base() const;
  ::Proto::ItemBase* release_item_base();
  ::Proto::ItemBase* mutable_item_base();
  void set_allocated_item_base(::Proto::ItemBase* item_base);

  // uint64 sn = 1;
  void clear_sn();
  ::PROTOBUF_NAMESPACE_ID::uint64 sn() const;
  void set_sn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:Proto.Item)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::ItemBase* item_base_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Skill :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Skill) */ {
 public:
  Skill();
  virtual ~Skill();

  Skill(const Skill& from);
  Skill(Skill&& from) noexcept
    : Skill() {
    *this = ::std::move(from);
  }

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skill& operator=(Skill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Skill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Skill* internal_default_instance() {
    return reinterpret_cast<const Skill*>(
               &_Skill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Skill& a, Skill& b) {
    a.Swap(&b);
  }
  inline void Swap(Skill* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Skill* New() const final {
    return CreateMaybeMessage<Skill>(nullptr);
  }

  Skill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Skill>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Skill& from);
  void MergeFrom(const Skill& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skill* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Skill";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIdFieldNumber = 1,
    kSkillLevelFieldNumber = 2,
  };
  // int32 skill_id = 1;
  void clear_skill_id();
  ::PROTOBUF_NAMESPACE_ID::int32 skill_id() const;
  void set_skill_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 skill_level = 2;
  void clear_skill_level();
  ::PROTOBUF_NAMESPACE_ID::int32 skill_level() const;
  void set_skill_level(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Skill)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 skill_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 skill_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PlayerItem :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerItem) */ {
 public:
  PlayerItem();
  virtual ~PlayerItem();

  PlayerItem(const PlayerItem& from);
  PlayerItem(PlayerItem&& from) noexcept
    : PlayerItem() {
    *this = ::std::move(from);
  }

  inline PlayerItem& operator=(const PlayerItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerItem& operator=(PlayerItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerItem* internal_default_instance() {
    return reinterpret_cast<const PlayerItem*>(
               &_PlayerItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerItem& a, PlayerItem& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerItem* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerItem* New() const final {
    return CreateMaybeMessage<PlayerItem>(nullptr);
  }

  PlayerItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerItem>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerItem& from);
  void MergeFrom(const PlayerItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.PlayerItem";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kBagsFieldNumber = 2,
  };
  // repeated .Proto.Item items = 1;
  int items_size() const;
  void clear_items();
  ::Proto::Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Item >*
      mutable_items();
  const ::Proto::Item& items(int index) const;
  ::Proto::Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Item >&
      items() const;

  // repeated uint64 bags = 2;
  int bags_size() const;
  void clear_bags();
  ::PROTOBUF_NAMESPACE_ID::uint64 bags(int index) const;
  void set_bags(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_bags(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      bags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_bags();

  // @@protoc_insertion_point(class_scope:Proto.PlayerItem)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Item > items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > bags_;
  mutable std::atomic<int> _bags_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Equipment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Equipment) */ {
 public:
  Equipment();
  virtual ~Equipment();

  Equipment(const Equipment& from);
  Equipment(Equipment&& from) noexcept
    : Equipment() {
    *this = ::std::move(from);
  }

  inline Equipment& operator=(const Equipment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Equipment& operator=(Equipment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Equipment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Equipment* internal_default_instance() {
    return reinterpret_cast<const Equipment*>(
               &_Equipment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Equipment& a, Equipment& b) {
    a.Swap(&b);
  }
  inline void Swap(Equipment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Equipment* New() const final {
    return CreateMaybeMessage<Equipment>(nullptr);
  }

  Equipment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Equipment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Equipment& from);
  void MergeFrom(const Equipment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equipment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Equipment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 level = 2;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Equipment)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Card :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Card) */ {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Card& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const final {
    return CreateMaybeMessage<Card>(nullptr);
  }

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Card";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Card_CardCareerType CardCareerType;
  static constexpr CardCareerType none =
    Card_CardCareerType_none;
  static constexpr CardCareerType ghost =
    Card_CardCareerType_ghost;
  static constexpr CardCareerType king =
    Card_CardCareerType_king;
  static constexpr CardCareerType god =
    Card_CardCareerType_god;
  static constexpr CardCareerType should =
    Card_CardCareerType_should;
  static constexpr CardCareerType Master =
    Card_CardCareerType_Master;
  static inline bool CardCareerType_IsValid(int value) {
    return Card_CardCareerType_IsValid(value);
  }
  static constexpr CardCareerType CardCareerType_MIN =
    Card_CardCareerType_CardCareerType_MIN;
  static constexpr CardCareerType CardCareerType_MAX =
    Card_CardCareerType_CardCareerType_MAX;
  static constexpr int CardCareerType_ARRAYSIZE =
    Card_CardCareerType_CardCareerType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CardCareerType_descriptor() {
    return Card_CardCareerType_descriptor();
  }
  template<typename T>
  static inline const std::string& CardCareerType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CardCareerType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CardCareerType_Name.");
    return Card_CardCareerType_Name(enum_t_value);
  }
  static inline bool CardCareerType_Parse(const std::string& name,
      CardCareerType* value) {
    return Card_CardCareerType_Parse(name, value);
  }

  typedef Card_CardCultivateState CardCultivateState;
  static constexpr CardCultivateState CLEVEL =
    Card_CardCultivateState_CLEVEL;
  static constexpr CardCultivateState CSTAR =
    Card_CardCultivateState_CSTAR;
  static constexpr CardCultivateState CQLT =
    Card_CardCultivateState_CQLT;
  static inline bool CardCultivateState_IsValid(int value) {
    return Card_CardCultivateState_IsValid(value);
  }
  static constexpr CardCultivateState CardCultivateState_MIN =
    Card_CardCultivateState_CardCultivateState_MIN;
  static constexpr CardCultivateState CardCultivateState_MAX =
    Card_CardCultivateState_CardCultivateState_MAX;
  static constexpr int CardCultivateState_ARRAYSIZE =
    Card_CardCultivateState_CardCultivateState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CardCultivateState_descriptor() {
    return Card_CardCultivateState_descriptor();
  }
  template<typename T>
  static inline const std::string& CardCultivateState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CardCultivateState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CardCultivateState_Name.");
    return Card_CardCultivateState_Name(enum_t_value);
  }
  static inline bool CardCultivateState_Parse(const std::string& name,
      CardCultivateState* value) {
    return Card_CardCultivateState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSkillsFieldNumber = 15,
    kIdFieldNumber = 1,
    kLevelFieldNumber = 2,
    kCharacterFieldNumber = 3,
    kStarFieldNumber = 4,
    kGetedTimeFieldNumber = 6,
    kAptitudeFieldNumber = 7,
    kCareerFieldNumber = 8,
    kAttFieldNumber = 9,
    kAttspeedFieldNumber = 10,
    kDefFieldNumber = 11,
    kHpFieldNumber = 12,
    kIntensifyTimesFieldNumber = 13,
    kCurExpFieldNumber = 14,
    kCardCltStateFieldNumber = 16,
    kFightPowerFieldNumber = 17,
    kIntensifyLvFieldNumber = 18,
  };
  // repeated .Proto.Skill skills = 15;
  int skills_size() const;
  void clear_skills();
  ::Proto::Skill* mutable_skills(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >*
      mutable_skills();
  const ::Proto::Skill& skills(int index) const;
  ::Proto::Skill* add_skills();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >&
      skills() const;

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 level = 2;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 character = 3;
  void clear_character();
  ::PROTOBUF_NAMESPACE_ID::int32 character() const;
  void set_character(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 star = 4;
  void clear_star();
  ::PROTOBUF_NAMESPACE_ID::int32 star() const;
  void set_star(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int64 geted_time = 6;
  void clear_geted_time();
  ::PROTOBUF_NAMESPACE_ID::int64 geted_time() const;
  void set_geted_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 aptitude = 7;
  void clear_aptitude();
  ::PROTOBUF_NAMESPACE_ID::int32 aptitude() const;
  void set_aptitude(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .Proto.Card.CardCareerType career = 8;
  void clear_career();
  ::Proto::Card_CardCareerType career() const;
  void set_career(::Proto::Card_CardCareerType value);

  // int32 att = 9;
  void clear_att();
  ::PROTOBUF_NAMESPACE_ID::int32 att() const;
  void set_att(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 attspeed = 10;
  void clear_attspeed();
  ::PROTOBUF_NAMESPACE_ID::int32 attspeed() const;
  void set_attspeed(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 def = 11;
  void clear_def();
  ::PROTOBUF_NAMESPACE_ID::int32 def() const;
  void set_def(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 hp = 12;
  void clear_hp();
  ::PROTOBUF_NAMESPACE_ID::int32 hp() const;
  void set_hp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 intensify_times = 13;
  void clear_intensify_times();
  ::PROTOBUF_NAMESPACE_ID::int32 intensify_times() const;
  void set_intensify_times(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 curExp = 14;
  void clear_curexp();
  ::PROTOBUF_NAMESPACE_ID::int32 curexp() const;
  void set_curexp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .Proto.Card.CardCultivateState cardCltState = 16;
  void clear_cardcltstate();
  ::Proto::Card_CardCultivateState cardcltstate() const;
  void set_cardcltstate(::Proto::Card_CardCultivateState value);

  // int32 fightPower = 17;
  void clear_fightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 fightpower() const;
  void set_fightpower(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 intensify_lv = 18;
  void clear_intensify_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 intensify_lv() const;
  void set_intensify_lv(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Card)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill > skills_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  ::PROTOBUF_NAMESPACE_ID::int32 character_;
  ::PROTOBUF_NAMESPACE_ID::int32 star_;
  ::PROTOBUF_NAMESPACE_ID::int64 geted_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 aptitude_;
  int career_;
  ::PROTOBUF_NAMESPACE_ID::int32 att_;
  ::PROTOBUF_NAMESPACE_ID::int32 attspeed_;
  ::PROTOBUF_NAMESPACE_ID::int32 def_;
  ::PROTOBUF_NAMESPACE_ID::int32 hp_;
  ::PROTOBUF_NAMESPACE_ID::int32 intensify_times_;
  ::PROTOBUF_NAMESPACE_ID::int32 curexp_;
  int cardcltstate_;
  ::PROTOBUF_NAMESPACE_ID::int32 fightpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 intensify_lv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class CardTeam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.CardTeam) */ {
 public:
  CardTeam();
  virtual ~CardTeam();

  CardTeam(const CardTeam& from);
  CardTeam(CardTeam&& from) noexcept
    : CardTeam() {
    *this = ::std::move(from);
  }

  inline CardTeam& operator=(const CardTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardTeam& operator=(CardTeam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CardTeam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardTeam* internal_default_instance() {
    return reinterpret_cast<const CardTeam*>(
               &_CardTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CardTeam& a, CardTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(CardTeam* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardTeam* New() const final {
    return CreateMaybeMessage<CardTeam>(nullptr);
  }

  CardTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardTeam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CardTeam& from);
  void MergeFrom(const CardTeam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardTeam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.CardTeam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kCardIdFieldNumber = 2,
  };
  // int32 pos = 1;
  void clear_pos();
  ::PROTOBUF_NAMESPACE_ID::int32 pos() const;
  void set_pos(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 card_id = 2;
  void clear_card_id();
  ::PROTOBUF_NAMESPACE_ID::int32 card_id() const;
  void set_card_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.CardTeam)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 pos_;
  ::PROTOBUF_NAMESPACE_ID::int32 card_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Team :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Team) */ {
 public:
  Team();
  virtual ~Team();

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Team& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Team* New() const final {
    return CreateMaybeMessage<Team>(nullptr);
  }

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Team";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Team_TeamType TeamType;
  static constexpr TeamType Normal =
    Team_TeamType_Normal;
  static inline bool TeamType_IsValid(int value) {
    return Team_TeamType_IsValid(value);
  }
  static constexpr TeamType TeamType_MIN =
    Team_TeamType_TeamType_MIN;
  static constexpr TeamType TeamType_MAX =
    Team_TeamType_TeamType_MAX;
  static constexpr int TeamType_ARRAYSIZE =
    Team_TeamType_TeamType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TeamType_descriptor() {
    return Team_TeamType_descriptor();
  }
  template<typename T>
  static inline const std::string& TeamType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TeamType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TeamType_Name.");
    return Team_TeamType_Name(enum_t_value);
  }
  static inline bool TeamType_Parse(const std::string& name,
      TeamType* value) {
    return Team_TeamType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 3,
    kTeamTypeFieldNumber = 1,
  };
  // repeated .Proto.CardTeam cards = 3;
  int cards_size() const;
  void clear_cards();
  ::Proto::CardTeam* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::CardTeam >*
      mutable_cards();
  const ::Proto::CardTeam& cards(int index) const;
  ::Proto::CardTeam* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::CardTeam >&
      cards() const;

  // .Proto.Team.TeamType team_type = 1;
  void clear_team_type();
  ::Proto::Team_TeamType team_type() const;
  void set_team_type(::Proto::Team_TeamType value);

  // @@protoc_insertion_point(class_scope:Proto.Team)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::CardTeam > cards_;
  int team_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PlayerCard :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerCard) */ {
 public:
  PlayerCard();
  virtual ~PlayerCard();

  PlayerCard(const PlayerCard& from);
  PlayerCard(PlayerCard&& from) noexcept
    : PlayerCard() {
    *this = ::std::move(from);
  }

  inline PlayerCard& operator=(const PlayerCard& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCard& operator=(PlayerCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerCard* internal_default_instance() {
    return reinterpret_cast<const PlayerCard*>(
               &_PlayerCard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerCard& a, PlayerCard& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCard* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerCard* New() const final {
    return CreateMaybeMessage<PlayerCard>(nullptr);
  }

  PlayerCard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCard>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerCard& from);
  void MergeFrom(const PlayerCard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCard* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.PlayerCard";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardsFieldNumber = 1,
    kTeamsFieldNumber = 2,
  };
  // repeated .Proto.Card cards = 1;
  int cards_size() const;
  void clear_cards();
  ::Proto::Card* mutable_cards(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Card >*
      mutable_cards();
  const ::Proto::Card& cards(int index) const;
  ::Proto::Card* add_cards();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Card >&
      cards() const;

  // repeated .Proto.Team teams = 2;
  int teams_size() const;
  void clear_teams();
  ::Proto::Team* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Team >*
      mutable_teams();
  const ::Proto::Team& teams(int index) const;
  ::Proto::Team* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Team >&
      teams() const;

  // @@protoc_insertion_point(class_scope:Proto.PlayerCard)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Card > cards_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Team > teams_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PlayerCharacter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerCharacter) */ {
 public:
  PlayerCharacter();
  virtual ~PlayerCharacter();

  PlayerCharacter(const PlayerCharacter& from);
  PlayerCharacter(PlayerCharacter&& from) noexcept
    : PlayerCharacter() {
    *this = ::std::move(from);
  }

  inline PlayerCharacter& operator=(const PlayerCharacter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerCharacter& operator=(PlayerCharacter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerCharacter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerCharacter* internal_default_instance() {
    return reinterpret_cast<const PlayerCharacter*>(
               &_PlayerCharacter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PlayerCharacter& a, PlayerCharacter& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerCharacter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerCharacter* New() const final {
    return CreateMaybeMessage<PlayerCharacter>(nullptr);
  }

  PlayerCharacter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCharacter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerCharacter& from);
  void MergeFrom(const PlayerCharacter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCharacter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.PlayerCharacter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillsFieldNumber = 1,
    kEquipmentsFieldNumber = 2,
  };
  // repeated .Proto.Skill skills = 1;
  int skills_size() const;
  void clear_skills();
  ::Proto::Skill* mutable_skills(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >*
      mutable_skills();
  const ::Proto::Skill& skills(int index) const;
  ::Proto::Skill* add_skills();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >&
      skills() const;

  // repeated .Proto.Equipment equipments = 2;
  int equipments_size() const;
  void clear_equipments();
  ::Proto::Equipment* mutable_equipments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Equipment >*
      mutable_equipments();
  const ::Proto::Equipment& equipments(int index) const;
  ::Proto::Equipment* add_equipments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Equipment >&
      equipments() const;

  // @@protoc_insertion_point(class_scope:Proto.PlayerCharacter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill > skills_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Equipment > equipments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PlayerBase :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerBase) */ {
 public:
  PlayerBase();
  virtual ~PlayerBase();

  PlayerBase(const PlayerBase& from);
  PlayerBase(PlayerBase&& from) noexcept
    : PlayerBase() {
    *this = ::std::move(from);
  }

  inline PlayerBase& operator=(const PlayerBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBase& operator=(PlayerBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerBase* internal_default_instance() {
    return reinterpret_cast<const PlayerBase*>(
               &_PlayerBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlayerBase& a, PlayerBase& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerBase* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerBase* New() const final {
    return CreateMaybeMessage<PlayerBase>(nullptr);
  }

  PlayerBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerBase>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerBase& from);
  void MergeFrom(const PlayerBase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerBase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.PlayerBase";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 2,
    kExpFieldNumber = 3,
    kVipLevelFieldNumber = 4,
    kVipExpFieldNumber = 5,
    kGuildSnFieldNumber = 7,
    kTemplateIdFieldNumber = 6,
    kGoldFieldNumber = 9,
    kTeamSnFieldNumber = 8,
    kDiamondFieldNumber = 10,
    kMuteFieldNumber = 11,
  };
  // int32 level = 2;
  void clear_level();
  ::PROTOBUF_NAMESPACE_ID::int32 level() const;
  void set_level(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 exp = 3;
  void clear_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 exp() const;
  void set_exp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 vip_level = 4;
  void clear_vip_level();
  ::PROTOBUF_NAMESPACE_ID::int32 vip_level() const;
  void set_vip_level(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 vip_exp = 5;
  void clear_vip_exp();
  ::PROTOBUF_NAMESPACE_ID::int32 vip_exp() const;
  void set_vip_exp(::PROTOBUF_NAMESPACE_ID::int32 value);

  // uint64 guild_sn = 7;
  void clear_guild_sn();
  ::PROTOBUF_NAMESPACE_ID::uint64 guild_sn() const;
  void set_guild_sn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int32 template_id = 6;
  void clear_template_id();
  ::PROTOBUF_NAMESPACE_ID::int32 template_id() const;
  void set_template_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 gold = 9;
  void clear_gold();
  ::PROTOBUF_NAMESPACE_ID::int32 gold() const;
  void set_gold(::PROTOBUF_NAMESPACE_ID::int32 value);

  // uint64 team_sn = 8;
  void clear_team_sn();
  ::PROTOBUF_NAMESPACE_ID::uint64 team_sn() const;
  void set_team_sn(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int32 diamond = 10;
  void clear_diamond();
  ::PROTOBUF_NAMESPACE_ID::int32 diamond() const;
  void set_diamond(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool mute = 11;
  void clear_mute();
  bool mute() const;
  void set_mute(bool value);

  // @@protoc_insertion_point(class_scope:Proto.PlayerBase)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 level_;
  ::PROTOBUF_NAMESPACE_ID::int32 exp_;
  ::PROTOBUF_NAMESPACE_ID::int32 vip_level_;
  ::PROTOBUF_NAMESPACE_ID::int32 vip_exp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 guild_sn_;
  ::PROTOBUF_NAMESPACE_ID::int32 template_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 gold_;
  ::PROTOBUF_NAMESPACE_ID::uint64 team_sn_;
  ::PROTOBUF_NAMESPACE_ID::int32 diamond_;
  bool mute_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class LastWorld :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.LastWorld) */ {
 public:
  LastWorld();
  virtual ~LastWorld();

  LastWorld(const LastWorld& from);
  LastWorld(LastWorld&& from) noexcept
    : LastWorld() {
    *this = ::std::move(from);
  }

  inline LastWorld& operator=(const LastWorld& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastWorld& operator=(LastWorld&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LastWorld& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LastWorld* internal_default_instance() {
    return reinterpret_cast<const LastWorld*>(
               &_LastWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LastWorld& a, LastWorld& b) {
    a.Swap(&b);
  }
  inline void Swap(LastWorld* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LastWorld* New() const final {
    return CreateMaybeMessage<LastWorld>(nullptr);
  }

  LastWorld* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LastWorld>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LastWorld& from);
  void MergeFrom(const LastWorld& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LastWorld* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.LastWorld";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kRotatorFieldNumber = 4,
    kWorldSnFieldNumber = 2,
    kWorldIdFieldNumber = 1,
  };
  // .Proto.Vector3 position = 3;
  bool has_position() const;
  void clear_position();
  const ::Proto::Vector3& position() const;
  ::Proto::Vector3* release_position();
  ::Proto::Vector3* mutable_position();
  void set_allocated_position(::Proto::Vector3* position);

  // .Proto.Vector3 rotator = 4;
  bool has_rotator() const;
  void clear_rotator();
  const ::Proto::Vector3& rotator() const;
  ::Proto::Vector3* release_rotator();
  ::Proto::Vector3* mutable_rotator();
  void set_allocated_rotator(::Proto::Vector3* rotator);

  // int64 world_sn = 2;
  void clear_world_sn();
  ::PROTOBUF_NAMESPACE_ID::int64 world_sn() const;
  void set_world_sn(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 world_id = 1;
  void clear_world_id();
  ::PROTOBUF_NAMESPACE_ID::int32 world_id() const;
  void set_world_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.LastWorld)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Vector3* position_;
  ::Proto::Vector3* rotator_;
  ::PROTOBUF_NAMESPACE_ID::int64 world_sn_;
  ::PROTOBUF_NAMESPACE_ID::int32 world_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class PlayerMisc :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerMisc) */ {
 public:
  PlayerMisc();
  virtual ~PlayerMisc();

  PlayerMisc(const PlayerMisc& from);
  PlayerMisc(PlayerMisc&& from) noexcept
    : PlayerMisc() {
    *this = ::std::move(from);
  }

  inline PlayerMisc& operator=(const PlayerMisc& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMisc& operator=(PlayerMisc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerMisc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerMisc* internal_default_instance() {
    return reinterpret_cast<const PlayerMisc*>(
               &_PlayerMisc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PlayerMisc& a, PlayerMisc& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMisc* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerMisc* New() const final {
    return CreateMaybeMessage<PlayerMisc>(nullptr);
  }

  PlayerMisc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerMisc>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerMisc& from);
  void MergeFrom(const PlayerMisc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMisc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.PlayerMisc";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropRecordsFieldNumber = 4,
    kGachaRecordsFieldNumber = 5,
    kLastWorldFieldNumber = 1,
    kOnlineVersionFieldNumber = 3,
  };
  // repeated .Proto.DropRecord drop_records = 4;
  int drop_records_size() const;
  void clear_drop_records();
  ::Proto::DropRecord* mutable_drop_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >*
      mutable_drop_records();
  const ::Proto::DropRecord& drop_records(int index) const;
  ::Proto::DropRecord* add_drop_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >&
      drop_records() const;

  // repeated .Proto.DropRecord gacha_records = 5;
  int gacha_records_size() const;
  void clear_gacha_records();
  ::Proto::DropRecord* mutable_gacha_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >*
      mutable_gacha_records();
  const ::Proto::DropRecord& gacha_records(int index) const;
  ::Proto::DropRecord* add_gacha_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >&
      gacha_records() const;

  // .Proto.LastWorld last_world = 1;
  bool has_last_world() const;
  void clear_last_world();
  const ::Proto::LastWorld& last_world() const;
  ::Proto::LastWorld* release_last_world();
  ::Proto::LastWorld* mutable_last_world();
  void set_allocated_last_world(::Proto::LastWorld* last_world);

  // int32 online_version = 3;
  void clear_online_version();
  ::PROTOBUF_NAMESPACE_ID::int32 online_version() const;
  void set_online_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.PlayerMisc)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord > drop_records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord > gacha_records_;
  ::Proto::LastWorld* last_world_;
  ::PROTOBUF_NAMESPACE_ID::int32 online_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class DropRecord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.DropRecord) */ {
 public:
  DropRecord();
  virtual ~DropRecord();

  DropRecord(const DropRecord& from);
  DropRecord(DropRecord&& from) noexcept
    : DropRecord() {
    *this = ::std::move(from);
  }

  inline DropRecord& operator=(const DropRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropRecord& operator=(DropRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DropRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DropRecord* internal_default_instance() {
    return reinterpret_cast<const DropRecord*>(
               &_DropRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DropRecord& a, DropRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(DropRecord* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DropRecord* New() const final {
    return CreateMaybeMessage<DropRecord>(nullptr);
  }

  DropRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DropRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DropRecord& from);
  void MergeFrom(const DropRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.DropRecord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 count = 2;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DropRecord)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class DBAccount :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.DBAccount) */ {
 public:
  DBAccount();
  virtual ~DBAccount();

  DBAccount(const DBAccount& from);
  DBAccount(DBAccount&& from) noexcept
    : DBAccount() {
    *this = ::std::move(from);
  }

  inline DBAccount& operator=(const DBAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBAccount& operator=(DBAccount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DBAccount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBAccount* internal_default_instance() {
    return reinterpret_cast<const DBAccount*>(
               &_DBAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DBAccount& a, DBAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(DBAccount* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DBAccount* New() const final {
    return CreateMaybeMessage<DBAccount>(nullptr);
  }

  DBAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DBAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DBAccount& from);
  void MergeFrom(const DBAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.DBAccount";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 3,
    kUuidFieldNumber = 4,
    kAccountFieldNumber = 5,
    kNameFieldNumber = 6,
    kSnFieldNumber = 1,
    kServeridFieldNumber = 2,
  };
  // string channel = 3;
  void clear_channel();
  const std::string& channel() const;
  void set_channel(const std::string& value);
  void set_channel(std::string&& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  std::string* mutable_channel();
  std::string* release_channel();
  void set_allocated_channel(std::string* channel);

  // string uuid = 4;
  void clear_uuid();
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);

  // string account = 5;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);

  // bytes name = 6;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int64 sn = 1;
  void clear_sn();
  ::PROTOBUF_NAMESPACE_ID::int64 sn() const;
  void set_sn(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 serverid = 2;
  void clear_serverid();
  ::PROTOBUF_NAMESPACE_ID::int32 serverid() const;
  void set_serverid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DBAccount)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 sn_;
  ::PROTOBUF_NAMESPACE_ID::int32 serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 3,
    kUuidFieldNumber = 4,
    kAccountFieldNumber = 5,
    kNameFieldNumber = 6,
    kBaseFieldNumber = 7,
    kMiscFieldNumber = 8,
    kItemFieldNumber = 9,
    kCardFieldNumber = 10,
    kCharacterFieldNumber = 11,
    kSnFieldNumber = 1,
    kServeridFieldNumber = 2,
  };
  // string channel = 3;
  void clear_channel();
  const std::string& channel() const;
  void set_channel(const std::string& value);
  void set_channel(std::string&& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  std::string* mutable_channel();
  std::string* release_channel();
  void set_allocated_channel(std::string* channel);

  // string uuid = 4;
  void clear_uuid();
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);

  // string account = 5;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);

  // bytes name = 6;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .Proto.PlayerBase base = 7;
  bool has_base() const;
  void clear_base();
  const ::Proto::PlayerBase& base() const;
  ::Proto::PlayerBase* release_base();
  ::Proto::PlayerBase* mutable_base();
  void set_allocated_base(::Proto::PlayerBase* base);

  // .Proto.PlayerMisc misc = 8;
  bool has_misc() const;
  void clear_misc();
  const ::Proto::PlayerMisc& misc() const;
  ::Proto::PlayerMisc* release_misc();
  ::Proto::PlayerMisc* mutable_misc();
  void set_allocated_misc(::Proto::PlayerMisc* misc);

  // .Proto.PlayerItem item = 9;
  bool has_item() const;
  void clear_item();
  const ::Proto::PlayerItem& item() const;
  ::Proto::PlayerItem* release_item();
  ::Proto::PlayerItem* mutable_item();
  void set_allocated_item(::Proto::PlayerItem* item);

  // .Proto.PlayerCard card = 10;
  bool has_card() const;
  void clear_card();
  const ::Proto::PlayerCard& card() const;
  ::Proto::PlayerCard* release_card();
  ::Proto::PlayerCard* mutable_card();
  void set_allocated_card(::Proto::PlayerCard* card);

  // .Proto.PlayerCharacter character = 11;
  bool has_character() const;
  void clear_character();
  const ::Proto::PlayerCharacter& character() const;
  ::Proto::PlayerCharacter* release_character();
  ::Proto::PlayerCharacter* mutable_character();
  void set_allocated_character(::Proto::PlayerCharacter* character);

  // int64 sn = 1;
  void clear_sn();
  ::PROTOBUF_NAMESPACE_ID::int64 sn() const;
  void set_sn(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 serverid = 2;
  void clear_serverid();
  ::PROTOBUF_NAMESPACE_ID::int32 serverid() const;
  void set_serverid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Player)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Proto::PlayerBase* base_;
  ::Proto::PlayerMisc* misc_;
  ::Proto::PlayerItem* item_;
  ::Proto::PlayerCard* card_;
  ::Proto::PlayerCharacter* character_;
  ::PROTOBUF_NAMESPACE_ID::int64 sn_;
  ::PROTOBUF_NAMESPACE_ID::int32 serverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class Position :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.Position";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .Proto.Vector3 location = 1;
  bool has_location() const;
  void clear_location();
  const ::Proto::Vector3& location() const;
  ::Proto::Vector3* release_location();
  ::Proto::Vector3* mutable_location();
  void set_allocated_location(::Proto::Vector3* location);

  // .Proto.Vector3 rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  const ::Proto::Vector3& rotation() const;
  ::Proto::Vector3* release_rotation();
  ::Proto::Vector3* mutable_rotation();
  void set_allocated_rotation(::Proto::Vector3* rotation);

  // @@protoc_insertion_point(class_scope:Proto.Position)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Vector3* location_;
  ::Proto::Vector3* rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class NPC :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.NPC) */ {
 public:
  NPC();
  virtual ~NPC();

  NPC(const NPC& from);
  NPC(NPC&& from) noexcept
    : NPC() {
    *this = ::std::move(from);
  }

  inline NPC& operator=(const NPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline NPC& operator=(NPC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NPC* internal_default_instance() {
    return reinterpret_cast<const NPC*>(
               &_NPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NPC& a, NPC& b) {
    a.Swap(&b);
  }
  inline void Swap(NPC* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NPC* New() const final {
    return CreateMaybeMessage<NPC>(nullptr);
  }

  NPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NPC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NPC& from);
  void MergeFrom(const NPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NPC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.NPC";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitPosFieldNumber = 5,
    kCurPosFieldNumber = 6,
    kNextPosFieldNumber = 7,
    kSnFieldNumber = 2,
    kCreateTimeFieldNumber = 3,
    kDieTimeFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // .Proto.Position init_pos = 5;
  bool has_init_pos() const;
  void clear_init_pos();
  const ::Proto::Position& init_pos() const;
  ::Proto::Position* release_init_pos();
  ::Proto::Position* mutable_init_pos();
  void set_allocated_init_pos(::Proto::Position* init_pos);

  // .Proto.Position cur_pos = 6;
  bool has_cur_pos() const;
  void clear_cur_pos();
  const ::Proto::Position& cur_pos() const;
  ::Proto::Position* release_cur_pos();
  ::Proto::Position* mutable_cur_pos();
  void set_allocated_cur_pos(::Proto::Position* cur_pos);

  // .Proto.Position next_pos = 7;
  bool has_next_pos() const;
  void clear_next_pos();
  const ::Proto::Position& next_pos() const;
  ::Proto::Position* release_next_pos();
  ::Proto::Position* mutable_next_pos();
  void set_allocated_next_pos(::Proto::Position* next_pos);

  // int64 sn = 2;
  void clear_sn();
  ::PROTOBUF_NAMESPACE_ID::int64 sn() const;
  void set_sn(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 create_time = 3;
  void clear_create_time();
  ::PROTOBUF_NAMESPACE_ID::int64 create_time() const;
  void set_create_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 die_time = 4;
  void clear_die_time();
  ::PROTOBUF_NAMESPACE_ID::int64 die_time() const;
  void set_die_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.NPC)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Position* init_pos_;
  ::Proto::Position* cur_pos_;
  ::Proto::Position* next_pos_;
  ::PROTOBUF_NAMESPACE_ID::int64 sn_;
  ::PROTOBUF_NAMESPACE_ID::int64 create_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 die_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class OBJ :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.OBJ) */ {
 public:
  OBJ();
  virtual ~OBJ();

  OBJ(const OBJ& from);
  OBJ(OBJ&& from) noexcept
    : OBJ() {
    *this = ::std::move(from);
  }

  inline OBJ& operator=(const OBJ& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBJ& operator=(OBJ&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OBJ& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OBJ* internal_default_instance() {
    return reinterpret_cast<const OBJ*>(
               &_OBJ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OBJ& a, OBJ& b) {
    a.Swap(&b);
  }
  inline void Swap(OBJ* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OBJ* New() const final {
    return CreateMaybeMessage<OBJ>(nullptr);
  }

  OBJ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OBJ>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OBJ& from);
  void MergeFrom(const OBJ& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBJ* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.OBJ";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitPosFieldNumber = 5,
    kCurPosFieldNumber = 6,
    kNextPosFieldNumber = 7,
    kSnFieldNumber = 2,
    kCreateTimeFieldNumber = 3,
    kDieTimeFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // .Proto.Position init_pos = 5;
  bool has_init_pos() const;
  void clear_init_pos();
  const ::Proto::Position& init_pos() const;
  ::Proto::Position* release_init_pos();
  ::Proto::Position* mutable_init_pos();
  void set_allocated_init_pos(::Proto::Position* init_pos);

  // .Proto.Position cur_pos = 6;
  bool has_cur_pos() const;
  void clear_cur_pos();
  const ::Proto::Position& cur_pos() const;
  ::Proto::Position* release_cur_pos();
  ::Proto::Position* mutable_cur_pos();
  void set_allocated_cur_pos(::Proto::Position* cur_pos);

  // .Proto.Position next_pos = 7;
  bool has_next_pos() const;
  void clear_next_pos();
  const ::Proto::Position& next_pos() const;
  ::Proto::Position* release_next_pos();
  ::Proto::Position* mutable_next_pos();
  void set_allocated_next_pos(::Proto::Position* next_pos);

  // int64 sn = 2;
  void clear_sn();
  ::PROTOBUF_NAMESPACE_ID::int64 sn() const;
  void set_sn(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 create_time = 3;
  void clear_create_time();
  ::PROTOBUF_NAMESPACE_ID::int64 create_time() const;
  void set_create_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 die_time = 4;
  void clear_die_time();
  ::PROTOBUF_NAMESPACE_ID::int64 die_time() const;
  void set_die_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.OBJ)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Position* init_pos_;
  ::Proto::Position* cur_pos_;
  ::Proto::Position* next_pos_;
  ::PROTOBUF_NAMESPACE_ID::int64 sn_;
  ::PROTOBUF_NAMESPACE_ID::int64 create_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 die_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class DBWorldData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Proto.DBWorldData) */ {
 public:
  DBWorldData();
  virtual ~DBWorldData();

  DBWorldData(const DBWorldData& from);
  DBWorldData(DBWorldData&& from) noexcept
    : DBWorldData() {
    *this = ::std::move(from);
  }

  inline DBWorldData& operator=(const DBWorldData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBWorldData& operator=(DBWorldData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DBWorldData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBWorldData* internal_default_instance() {
    return reinterpret_cast<const DBWorldData*>(
               &_DBWorldData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DBWorldData& a, DBWorldData& b) {
    a.Swap(&b);
  }
  inline void Swap(DBWorldData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DBWorldData* New() const final {
    return CreateMaybeMessage<DBWorldData>(nullptr);
  }

  DBWorldData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DBWorldData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DBWorldData& from);
  void MergeFrom(const DBWorldData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBWorldData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Proto.DBWorldData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_db_2eproto);
    return ::descriptor_table_db_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNpcListFieldNumber = 3,
    kObjListFieldNumber = 4,
    kServerIdFieldNumber = 1,
    kWorldIdFieldNumber = 2,
  };
  // repeated .Proto.NPC npc_list = 3;
  int npc_list_size() const;
  void clear_npc_list();
  ::Proto::NPC* mutable_npc_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::NPC >*
      mutable_npc_list();
  const ::Proto::NPC& npc_list(int index) const;
  ::Proto::NPC* add_npc_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::NPC >&
      npc_list() const;

  // repeated .Proto.OBJ obj_list = 4;
  int obj_list_size() const;
  void clear_obj_list();
  ::Proto::OBJ* mutable_obj_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::OBJ >*
      mutable_obj_list();
  const ::Proto::OBJ& obj_list(int index) const;
  ::Proto::OBJ* add_obj_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::OBJ >&
      obj_list() const;

  // int32 server_id = 1;
  void clear_server_id();
  ::PROTOBUF_NAMESPACE_ID::int32 server_id() const;
  void set_server_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 world_id = 2;
  void clear_world_id();
  ::PROTOBUF_NAMESPACE_ID::int32 world_id() const;
  void set_world_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.DBWorldData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::NPC > npc_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::OBJ > obj_list_;
  ::PROTOBUF_NAMESPACE_ID::int32 server_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 world_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_db_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Proto.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Proto.Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Proto.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Proto.Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Proto.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Proto.Vector3.z)
}

// -------------------------------------------------------------------

// ItemBase

// int32 id = 1;
inline void ItemBase::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemBase::id() const {
  // @@protoc_insertion_point(field_get:Proto.ItemBase.id)
  return id_;
}
inline void ItemBase::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.ItemBase.id)
}

// int32 num = 2;
inline void ItemBase::clear_num() {
  num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ItemBase::num() const {
  // @@protoc_insertion_point(field_get:Proto.ItemBase.num)
  return num_;
}
inline void ItemBase::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:Proto.ItemBase.num)
}

// -------------------------------------------------------------------

// Item

// uint64 sn = 1;
inline void Item::clear_sn() {
  sn_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Item::sn() const {
  // @@protoc_insertion_point(field_get:Proto.Item.sn)
  return sn_;
}
inline void Item::set_sn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.Item.sn)
}

// .Proto.ItemBase item_base = 2;
inline bool Item::has_item_base() const {
  return this != internal_default_instance() && item_base_ != nullptr;
}
inline void Item::clear_item_base() {
  if (GetArenaNoVirtual() == nullptr && item_base_ != nullptr) {
    delete item_base_;
  }
  item_base_ = nullptr;
}
inline const ::Proto::ItemBase& Item::item_base() const {
  const ::Proto::ItemBase* p = item_base_;
  // @@protoc_insertion_point(field_get:Proto.Item.item_base)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::ItemBase*>(
      &::Proto::_ItemBase_default_instance_);
}
inline ::Proto::ItemBase* Item::release_item_base() {
  // @@protoc_insertion_point(field_release:Proto.Item.item_base)
  
  ::Proto::ItemBase* temp = item_base_;
  item_base_ = nullptr;
  return temp;
}
inline ::Proto::ItemBase* Item::mutable_item_base() {
  
  if (item_base_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::ItemBase>(GetArenaNoVirtual());
    item_base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Item.item_base)
  return item_base_;
}
inline void Item::set_allocated_item_base(::Proto::ItemBase* item_base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete item_base_;
  }
  if (item_base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      item_base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item_base, submessage_arena);
    }
    
  } else {
    
  }
  item_base_ = item_base;
  // @@protoc_insertion_point(field_set_allocated:Proto.Item.item_base)
}

// -------------------------------------------------------------------

// Skill

// int32 skill_id = 1;
inline void Skill::clear_skill_id() {
  skill_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Skill::skill_id() const {
  // @@protoc_insertion_point(field_get:Proto.Skill.skill_id)
  return skill_id_;
}
inline void Skill::set_skill_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skill_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.Skill.skill_id)
}

// int32 skill_level = 2;
inline void Skill::clear_skill_level() {
  skill_level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Skill::skill_level() const {
  // @@protoc_insertion_point(field_get:Proto.Skill.skill_level)
  return skill_level_;
}
inline void Skill::set_skill_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  skill_level_ = value;
  // @@protoc_insertion_point(field_set:Proto.Skill.skill_level)
}

// -------------------------------------------------------------------

// PlayerItem

// repeated .Proto.Item items = 1;
inline int PlayerItem::items_size() const {
  return items_.size();
}
inline void PlayerItem::clear_items() {
  items_.Clear();
}
inline ::Proto::Item* PlayerItem::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerItem.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Item >*
PlayerItem::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerItem.items)
  return &items_;
}
inline const ::Proto::Item& PlayerItem::items(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerItem.items)
  return items_.Get(index);
}
inline ::Proto::Item* PlayerItem::add_items() {
  // @@protoc_insertion_point(field_add:Proto.PlayerItem.items)
  return items_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Item >&
PlayerItem::items() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerItem.items)
  return items_;
}

// repeated uint64 bags = 2;
inline int PlayerItem::bags_size() const {
  return bags_.size();
}
inline void PlayerItem::clear_bags() {
  bags_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PlayerItem::bags(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerItem.bags)
  return bags_.Get(index);
}
inline void PlayerItem::set_bags(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  bags_.Set(index, value);
  // @@protoc_insertion_point(field_set:Proto.PlayerItem.bags)
}
inline void PlayerItem::add_bags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  bags_.Add(value);
  // @@protoc_insertion_point(field_add:Proto.PlayerItem.bags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
PlayerItem::bags() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerItem.bags)
  return bags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
PlayerItem::mutable_bags() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerItem.bags)
  return &bags_;
}

// -------------------------------------------------------------------

// Equipment

// int32 id = 1;
inline void Equipment::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Equipment::id() const {
  // @@protoc_insertion_point(field_get:Proto.Equipment.id)
  return id_;
}
inline void Equipment::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.Equipment.id)
}

// int32 level = 2;
inline void Equipment::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Equipment::level() const {
  // @@protoc_insertion_point(field_get:Proto.Equipment.level)
  return level_;
}
inline void Equipment::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:Proto.Equipment.level)
}

// -------------------------------------------------------------------

// Card

// int32 id = 1;
inline void Card::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::id() const {
  // @@protoc_insertion_point(field_get:Proto.Card.id)
  return id_;
}
inline void Card::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.id)
}

// int32 level = 2;
inline void Card::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::level() const {
  // @@protoc_insertion_point(field_get:Proto.Card.level)
  return level_;
}
inline void Card::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.level)
}

// int32 character = 3;
inline void Card::clear_character() {
  character_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::character() const {
  // @@protoc_insertion_point(field_get:Proto.Card.character)
  return character_;
}
inline void Card::set_character(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  character_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.character)
}

// int32 star = 4;
inline void Card::clear_star() {
  star_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::star() const {
  // @@protoc_insertion_point(field_get:Proto.Card.star)
  return star_;
}
inline void Card::set_star(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  star_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.star)
}

// int64 geted_time = 6;
inline void Card::clear_geted_time() {
  geted_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Card::geted_time() const {
  // @@protoc_insertion_point(field_get:Proto.Card.geted_time)
  return geted_time_;
}
inline void Card::set_geted_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  geted_time_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.geted_time)
}

// int32 aptitude = 7;
inline void Card::clear_aptitude() {
  aptitude_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::aptitude() const {
  // @@protoc_insertion_point(field_get:Proto.Card.aptitude)
  return aptitude_;
}
inline void Card::set_aptitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  aptitude_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.aptitude)
}

// .Proto.Card.CardCareerType career = 8;
inline void Card::clear_career() {
  career_ = 0;
}
inline ::Proto::Card_CardCareerType Card::career() const {
  // @@protoc_insertion_point(field_get:Proto.Card.career)
  return static_cast< ::Proto::Card_CardCareerType >(career_);
}
inline void Card::set_career(::Proto::Card_CardCareerType value) {
  
  career_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.career)
}

// int32 att = 9;
inline void Card::clear_att() {
  att_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::att() const {
  // @@protoc_insertion_point(field_get:Proto.Card.att)
  return att_;
}
inline void Card::set_att(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  att_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.att)
}

// int32 attspeed = 10;
inline void Card::clear_attspeed() {
  attspeed_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::attspeed() const {
  // @@protoc_insertion_point(field_get:Proto.Card.attspeed)
  return attspeed_;
}
inline void Card::set_attspeed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attspeed_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.attspeed)
}

// int32 def = 11;
inline void Card::clear_def() {
  def_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::def() const {
  // @@protoc_insertion_point(field_get:Proto.Card.def)
  return def_;
}
inline void Card::set_def(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  def_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.def)
}

// int32 hp = 12;
inline void Card::clear_hp() {
  hp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::hp() const {
  // @@protoc_insertion_point(field_get:Proto.Card.hp)
  return hp_;
}
inline void Card::set_hp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hp_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.hp)
}

// int32 intensify_times = 13;
inline void Card::clear_intensify_times() {
  intensify_times_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::intensify_times() const {
  // @@protoc_insertion_point(field_get:Proto.Card.intensify_times)
  return intensify_times_;
}
inline void Card::set_intensify_times(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  intensify_times_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.intensify_times)
}

// int32 curExp = 14;
inline void Card::clear_curexp() {
  curexp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::curexp() const {
  // @@protoc_insertion_point(field_get:Proto.Card.curExp)
  return curexp_;
}
inline void Card::set_curexp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curexp_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.curExp)
}

// repeated .Proto.Skill skills = 15;
inline int Card::skills_size() const {
  return skills_.size();
}
inline void Card::clear_skills() {
  skills_.Clear();
}
inline ::Proto::Skill* Card::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Card.skills)
  return skills_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >*
Card::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Card.skills)
  return &skills_;
}
inline const ::Proto::Skill& Card::skills(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Card.skills)
  return skills_.Get(index);
}
inline ::Proto::Skill* Card::add_skills() {
  // @@protoc_insertion_point(field_add:Proto.Card.skills)
  return skills_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >&
Card::skills() const {
  // @@protoc_insertion_point(field_list:Proto.Card.skills)
  return skills_;
}

// .Proto.Card.CardCultivateState cardCltState = 16;
inline void Card::clear_cardcltstate() {
  cardcltstate_ = 0;
}
inline ::Proto::Card_CardCultivateState Card::cardcltstate() const {
  // @@protoc_insertion_point(field_get:Proto.Card.cardCltState)
  return static_cast< ::Proto::Card_CardCultivateState >(cardcltstate_);
}
inline void Card::set_cardcltstate(::Proto::Card_CardCultivateState value) {
  
  cardcltstate_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.cardCltState)
}

// int32 fightPower = 17;
inline void Card::clear_fightpower() {
  fightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::fightpower() const {
  // @@protoc_insertion_point(field_get:Proto.Card.fightPower)
  return fightpower_;
}
inline void Card::set_fightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fightpower_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.fightPower)
}

// int32 intensify_lv = 18;
inline void Card::clear_intensify_lv() {
  intensify_lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::intensify_lv() const {
  // @@protoc_insertion_point(field_get:Proto.Card.intensify_lv)
  return intensify_lv_;
}
inline void Card::set_intensify_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  intensify_lv_ = value;
  // @@protoc_insertion_point(field_set:Proto.Card.intensify_lv)
}

// -------------------------------------------------------------------

// CardTeam

// int32 pos = 1;
inline void CardTeam::clear_pos() {
  pos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CardTeam::pos() const {
  // @@protoc_insertion_point(field_get:Proto.CardTeam.pos)
  return pos_;
}
inline void CardTeam::set_pos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pos_ = value;
  // @@protoc_insertion_point(field_set:Proto.CardTeam.pos)
}

// int32 card_id = 2;
inline void CardTeam::clear_card_id() {
  card_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CardTeam::card_id() const {
  // @@protoc_insertion_point(field_get:Proto.CardTeam.card_id)
  return card_id_;
}
inline void CardTeam::set_card_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  card_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.CardTeam.card_id)
}

// -------------------------------------------------------------------

// Team

// .Proto.Team.TeamType team_type = 1;
inline void Team::clear_team_type() {
  team_type_ = 0;
}
inline ::Proto::Team_TeamType Team::team_type() const {
  // @@protoc_insertion_point(field_get:Proto.Team.team_type)
  return static_cast< ::Proto::Team_TeamType >(team_type_);
}
inline void Team::set_team_type(::Proto::Team_TeamType value) {
  
  team_type_ = value;
  // @@protoc_insertion_point(field_set:Proto.Team.team_type)
}

// repeated .Proto.CardTeam cards = 3;
inline int Team::cards_size() const {
  return cards_.size();
}
inline void Team::clear_cards() {
  cards_.Clear();
}
inline ::Proto::CardTeam* Team::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Team.cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::CardTeam >*
Team::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Team.cards)
  return &cards_;
}
inline const ::Proto::CardTeam& Team::cards(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Team.cards)
  return cards_.Get(index);
}
inline ::Proto::CardTeam* Team::add_cards() {
  // @@protoc_insertion_point(field_add:Proto.Team.cards)
  return cards_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::CardTeam >&
Team::cards() const {
  // @@protoc_insertion_point(field_list:Proto.Team.cards)
  return cards_;
}

// -------------------------------------------------------------------

// PlayerCard

// repeated .Proto.Card cards = 1;
inline int PlayerCard::cards_size() const {
  return cards_.size();
}
inline void PlayerCard::clear_cards() {
  cards_.Clear();
}
inline ::Proto::Card* PlayerCard::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerCard.cards)
  return cards_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Card >*
PlayerCard::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerCard.cards)
  return &cards_;
}
inline const ::Proto::Card& PlayerCard::cards(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerCard.cards)
  return cards_.Get(index);
}
inline ::Proto::Card* PlayerCard::add_cards() {
  // @@protoc_insertion_point(field_add:Proto.PlayerCard.cards)
  return cards_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Card >&
PlayerCard::cards() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerCard.cards)
  return cards_;
}

// repeated .Proto.Team teams = 2;
inline int PlayerCard::teams_size() const {
  return teams_.size();
}
inline void PlayerCard::clear_teams() {
  teams_.Clear();
}
inline ::Proto::Team* PlayerCard::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerCard.teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Team >*
PlayerCard::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerCard.teams)
  return &teams_;
}
inline const ::Proto::Team& PlayerCard::teams(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerCard.teams)
  return teams_.Get(index);
}
inline ::Proto::Team* PlayerCard::add_teams() {
  // @@protoc_insertion_point(field_add:Proto.PlayerCard.teams)
  return teams_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Team >&
PlayerCard::teams() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerCard.teams)
  return teams_;
}

// -------------------------------------------------------------------

// PlayerCharacter

// repeated .Proto.Skill skills = 1;
inline int PlayerCharacter::skills_size() const {
  return skills_.size();
}
inline void PlayerCharacter::clear_skills() {
  skills_.Clear();
}
inline ::Proto::Skill* PlayerCharacter::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerCharacter.skills)
  return skills_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >*
PlayerCharacter::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerCharacter.skills)
  return &skills_;
}
inline const ::Proto::Skill& PlayerCharacter::skills(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerCharacter.skills)
  return skills_.Get(index);
}
inline ::Proto::Skill* PlayerCharacter::add_skills() {
  // @@protoc_insertion_point(field_add:Proto.PlayerCharacter.skills)
  return skills_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Skill >&
PlayerCharacter::skills() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerCharacter.skills)
  return skills_;
}

// repeated .Proto.Equipment equipments = 2;
inline int PlayerCharacter::equipments_size() const {
  return equipments_.size();
}
inline void PlayerCharacter::clear_equipments() {
  equipments_.Clear();
}
inline ::Proto::Equipment* PlayerCharacter::mutable_equipments(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerCharacter.equipments)
  return equipments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Equipment >*
PlayerCharacter::mutable_equipments() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerCharacter.equipments)
  return &equipments_;
}
inline const ::Proto::Equipment& PlayerCharacter::equipments(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerCharacter.equipments)
  return equipments_.Get(index);
}
inline ::Proto::Equipment* PlayerCharacter::add_equipments() {
  // @@protoc_insertion_point(field_add:Proto.PlayerCharacter.equipments)
  return equipments_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::Equipment >&
PlayerCharacter::equipments() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerCharacter.equipments)
  return equipments_;
}

// -------------------------------------------------------------------

// PlayerBase

// int32 level = 2;
inline void PlayerBase::clear_level() {
  level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::level() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.level)
  return level_;
}
inline void PlayerBase::set_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.level)
}

// int32 exp = 3;
inline void PlayerBase::clear_exp() {
  exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::exp() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.exp)
  return exp_;
}
inline void PlayerBase::set_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  exp_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.exp)
}

// int32 vip_level = 4;
inline void PlayerBase::clear_vip_level() {
  vip_level_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::vip_level() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.vip_level)
  return vip_level_;
}
inline void PlayerBase::set_vip_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vip_level_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.vip_level)
}

// int32 vip_exp = 5;
inline void PlayerBase::clear_vip_exp() {
  vip_exp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::vip_exp() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.vip_exp)
  return vip_exp_;
}
inline void PlayerBase::set_vip_exp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  vip_exp_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.vip_exp)
}

// int32 template_id = 6;
inline void PlayerBase::clear_template_id() {
  template_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::template_id() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.template_id)
  return template_id_;
}
inline void PlayerBase::set_template_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  template_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.template_id)
}

// uint64 guild_sn = 7;
inline void PlayerBase::clear_guild_sn() {
  guild_sn_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PlayerBase::guild_sn() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.guild_sn)
  return guild_sn_;
}
inline void PlayerBase::set_guild_sn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  guild_sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.guild_sn)
}

// uint64 team_sn = 8;
inline void PlayerBase::clear_team_sn() {
  team_sn_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PlayerBase::team_sn() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.team_sn)
  return team_sn_;
}
inline void PlayerBase::set_team_sn(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  team_sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.team_sn)
}

// int32 gold = 9;
inline void PlayerBase::clear_gold() {
  gold_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::gold() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.gold)
  return gold_;
}
inline void PlayerBase::set_gold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gold_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.gold)
}

// int32 diamond = 10;
inline void PlayerBase::clear_diamond() {
  diamond_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerBase::diamond() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.diamond)
  return diamond_;
}
inline void PlayerBase::set_diamond(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  diamond_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.diamond)
}

// bool mute = 11;
inline void PlayerBase::clear_mute() {
  mute_ = false;
}
inline bool PlayerBase::mute() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerBase.mute)
  return mute_;
}
inline void PlayerBase::set_mute(bool value) {
  
  mute_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerBase.mute)
}

// -------------------------------------------------------------------

// LastWorld

// int32 world_id = 1;
inline void LastWorld::clear_world_id() {
  world_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LastWorld::world_id() const {
  // @@protoc_insertion_point(field_get:Proto.LastWorld.world_id)
  return world_id_;
}
inline void LastWorld::set_world_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  world_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.LastWorld.world_id)
}

// int64 world_sn = 2;
inline void LastWorld::clear_world_sn() {
  world_sn_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LastWorld::world_sn() const {
  // @@protoc_insertion_point(field_get:Proto.LastWorld.world_sn)
  return world_sn_;
}
inline void LastWorld::set_world_sn(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  world_sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.LastWorld.world_sn)
}

// .Proto.Vector3 position = 3;
inline bool LastWorld::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void LastWorld::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Proto::Vector3& LastWorld::position() const {
  const ::Proto::Vector3* p = position_;
  // @@protoc_insertion_point(field_get:Proto.LastWorld.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Vector3*>(
      &::Proto::_Vector3_default_instance_);
}
inline ::Proto::Vector3* LastWorld::release_position() {
  // @@protoc_insertion_point(field_release:Proto.LastWorld.position)
  
  ::Proto::Vector3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Proto::Vector3* LastWorld::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Vector3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.LastWorld.position)
  return position_;
}
inline void LastWorld::set_allocated_position(::Proto::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Proto.LastWorld.position)
}

// .Proto.Vector3 rotator = 4;
inline bool LastWorld::has_rotator() const {
  return this != internal_default_instance() && rotator_ != nullptr;
}
inline void LastWorld::clear_rotator() {
  if (GetArenaNoVirtual() == nullptr && rotator_ != nullptr) {
    delete rotator_;
  }
  rotator_ = nullptr;
}
inline const ::Proto::Vector3& LastWorld::rotator() const {
  const ::Proto::Vector3* p = rotator_;
  // @@protoc_insertion_point(field_get:Proto.LastWorld.rotator)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Vector3*>(
      &::Proto::_Vector3_default_instance_);
}
inline ::Proto::Vector3* LastWorld::release_rotator() {
  // @@protoc_insertion_point(field_release:Proto.LastWorld.rotator)
  
  ::Proto::Vector3* temp = rotator_;
  rotator_ = nullptr;
  return temp;
}
inline ::Proto::Vector3* LastWorld::mutable_rotator() {
  
  if (rotator_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Vector3>(GetArenaNoVirtual());
    rotator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.LastWorld.rotator)
  return rotator_;
}
inline void LastWorld::set_allocated_rotator(::Proto::Vector3* rotator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rotator_;
  }
  if (rotator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotator, submessage_arena);
    }
    
  } else {
    
  }
  rotator_ = rotator;
  // @@protoc_insertion_point(field_set_allocated:Proto.LastWorld.rotator)
}

// -------------------------------------------------------------------

// PlayerMisc

// .Proto.LastWorld last_world = 1;
inline bool PlayerMisc::has_last_world() const {
  return this != internal_default_instance() && last_world_ != nullptr;
}
inline void PlayerMisc::clear_last_world() {
  if (GetArenaNoVirtual() == nullptr && last_world_ != nullptr) {
    delete last_world_;
  }
  last_world_ = nullptr;
}
inline const ::Proto::LastWorld& PlayerMisc::last_world() const {
  const ::Proto::LastWorld* p = last_world_;
  // @@protoc_insertion_point(field_get:Proto.PlayerMisc.last_world)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::LastWorld*>(
      &::Proto::_LastWorld_default_instance_);
}
inline ::Proto::LastWorld* PlayerMisc::release_last_world() {
  // @@protoc_insertion_point(field_release:Proto.PlayerMisc.last_world)
  
  ::Proto::LastWorld* temp = last_world_;
  last_world_ = nullptr;
  return temp;
}
inline ::Proto::LastWorld* PlayerMisc::mutable_last_world() {
  
  if (last_world_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::LastWorld>(GetArenaNoVirtual());
    last_world_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.PlayerMisc.last_world)
  return last_world_;
}
inline void PlayerMisc::set_allocated_last_world(::Proto::LastWorld* last_world) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete last_world_;
  }
  if (last_world) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      last_world = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_world, submessage_arena);
    }
    
  } else {
    
  }
  last_world_ = last_world;
  // @@protoc_insertion_point(field_set_allocated:Proto.PlayerMisc.last_world)
}

// int32 online_version = 3;
inline void PlayerMisc::clear_online_version() {
  online_version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerMisc::online_version() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerMisc.online_version)
  return online_version_;
}
inline void PlayerMisc::set_online_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  online_version_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerMisc.online_version)
}

// repeated .Proto.DropRecord drop_records = 4;
inline int PlayerMisc::drop_records_size() const {
  return drop_records_.size();
}
inline void PlayerMisc::clear_drop_records() {
  drop_records_.Clear();
}
inline ::Proto::DropRecord* PlayerMisc::mutable_drop_records(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerMisc.drop_records)
  return drop_records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >*
PlayerMisc::mutable_drop_records() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerMisc.drop_records)
  return &drop_records_;
}
inline const ::Proto::DropRecord& PlayerMisc::drop_records(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerMisc.drop_records)
  return drop_records_.Get(index);
}
inline ::Proto::DropRecord* PlayerMisc::add_drop_records() {
  // @@protoc_insertion_point(field_add:Proto.PlayerMisc.drop_records)
  return drop_records_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >&
PlayerMisc::drop_records() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerMisc.drop_records)
  return drop_records_;
}

// repeated .Proto.DropRecord gacha_records = 5;
inline int PlayerMisc::gacha_records_size() const {
  return gacha_records_.size();
}
inline void PlayerMisc::clear_gacha_records() {
  gacha_records_.Clear();
}
inline ::Proto::DropRecord* PlayerMisc::mutable_gacha_records(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerMisc.gacha_records)
  return gacha_records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >*
PlayerMisc::mutable_gacha_records() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerMisc.gacha_records)
  return &gacha_records_;
}
inline const ::Proto::DropRecord& PlayerMisc::gacha_records(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerMisc.gacha_records)
  return gacha_records_.Get(index);
}
inline ::Proto::DropRecord* PlayerMisc::add_gacha_records() {
  // @@protoc_insertion_point(field_add:Proto.PlayerMisc.gacha_records)
  return gacha_records_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::DropRecord >&
PlayerMisc::gacha_records() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerMisc.gacha_records)
  return gacha_records_;
}

// -------------------------------------------------------------------

// DropRecord

// int32 id = 1;
inline void DropRecord::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DropRecord::id() const {
  // @@protoc_insertion_point(field_get:Proto.DropRecord.id)
  return id_;
}
inline void DropRecord::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.DropRecord.id)
}

// int32 count = 2;
inline void DropRecord::clear_count() {
  count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DropRecord::count() const {
  // @@protoc_insertion_point(field_get:Proto.DropRecord.count)
  return count_;
}
inline void DropRecord::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:Proto.DropRecord.count)
}

// -------------------------------------------------------------------

// DBAccount

// int64 sn = 1;
inline void DBAccount::clear_sn() {
  sn_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DBAccount::sn() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.sn)
  return sn_;
}
inline void DBAccount::set_sn(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.DBAccount.sn)
}

// int32 serverid = 2;
inline void DBAccount::clear_serverid() {
  serverid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DBAccount::serverid() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.serverid)
  return serverid_;
}
inline void DBAccount::set_serverid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:Proto.DBAccount.serverid)
}

// string channel = 3;
inline void DBAccount::clear_channel() {
  channel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DBAccount::channel() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.channel)
  return channel_.GetNoArena();
}
inline void DBAccount::set_channel(const std::string& value) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.DBAccount.channel)
}
inline void DBAccount::set_channel(std::string&& value) {
  
  channel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.DBAccount.channel)
}
inline void DBAccount::set_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.DBAccount.channel)
}
inline void DBAccount::set_channel(const char* value, size_t size) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.DBAccount.channel)
}
inline std::string* DBAccount::mutable_channel() {
  
  // @@protoc_insertion_point(field_mutable:Proto.DBAccount.channel)
  return channel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DBAccount::release_channel() {
  // @@protoc_insertion_point(field_release:Proto.DBAccount.channel)
  
  return channel_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DBAccount::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  channel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:Proto.DBAccount.channel)
}

// string uuid = 4;
inline void DBAccount::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DBAccount::uuid() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.uuid)
  return uuid_.GetNoArena();
}
inline void DBAccount::set_uuid(const std::string& value) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.DBAccount.uuid)
}
inline void DBAccount::set_uuid(std::string&& value) {
  
  uuid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.DBAccount.uuid)
}
inline void DBAccount::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.DBAccount.uuid)
}
inline void DBAccount::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.DBAccount.uuid)
}
inline std::string* DBAccount::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:Proto.DBAccount.uuid)
  return uuid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DBAccount::release_uuid() {
  // @@protoc_insertion_point(field_release:Proto.DBAccount.uuid)
  
  return uuid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DBAccount::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:Proto.DBAccount.uuid)
}

// string account = 5;
inline void DBAccount::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DBAccount::account() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.account)
  return account_.GetNoArena();
}
inline void DBAccount::set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.DBAccount.account)
}
inline void DBAccount::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.DBAccount.account)
}
inline void DBAccount::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.DBAccount.account)
}
inline void DBAccount::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.DBAccount.account)
}
inline std::string* DBAccount::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:Proto.DBAccount.account)
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DBAccount::release_account() {
  // @@protoc_insertion_point(field_release:Proto.DBAccount.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DBAccount::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:Proto.DBAccount.account)
}

// bytes name = 6;
inline void DBAccount::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DBAccount::name() const {
  // @@protoc_insertion_point(field_get:Proto.DBAccount.name)
  return name_.GetNoArena();
}
inline void DBAccount::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.DBAccount.name)
}
inline void DBAccount::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.DBAccount.name)
}
inline void DBAccount::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.DBAccount.name)
}
inline void DBAccount::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.DBAccount.name)
}
inline std::string* DBAccount::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Proto.DBAccount.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DBAccount::release_name() {
  // @@protoc_insertion_point(field_release:Proto.DBAccount.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DBAccount::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Proto.DBAccount.name)
}

// -------------------------------------------------------------------

// Player

// int64 sn = 1;
inline void Player::clear_sn() {
  sn_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Player::sn() const {
  // @@protoc_insertion_point(field_get:Proto.Player.sn)
  return sn_;
}
inline void Player::set_sn(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.Player.sn)
}

// int32 serverid = 2;
inline void Player::clear_serverid() {
  serverid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Player::serverid() const {
  // @@protoc_insertion_point(field_get:Proto.Player.serverid)
  return serverid_;
}
inline void Player::set_serverid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  serverid_ = value;
  // @@protoc_insertion_point(field_set:Proto.Player.serverid)
}

// string channel = 3;
inline void Player::clear_channel() {
  channel_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Player::channel() const {
  // @@protoc_insertion_point(field_get:Proto.Player.channel)
  return channel_.GetNoArena();
}
inline void Player::set_channel(const std::string& value) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Player.channel)
}
inline void Player::set_channel(std::string&& value) {
  
  channel_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Player.channel)
}
inline void Player::set_channel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Player.channel)
}
inline void Player::set_channel(const char* value, size_t size) {
  
  channel_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Player.channel)
}
inline std::string* Player::mutable_channel() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Player.channel)
  return channel_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Player::release_channel() {
  // @@protoc_insertion_point(field_release:Proto.Player.channel)
  
  return channel_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_channel(std::string* channel) {
  if (channel != nullptr) {
    
  } else {
    
  }
  channel_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.channel)
}

// string uuid = 4;
inline void Player::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Player::uuid() const {
  // @@protoc_insertion_point(field_get:Proto.Player.uuid)
  return uuid_.GetNoArena();
}
inline void Player::set_uuid(const std::string& value) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Player.uuid)
}
inline void Player::set_uuid(std::string&& value) {
  
  uuid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Player.uuid)
}
inline void Player::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Player.uuid)
}
inline void Player::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Player.uuid)
}
inline std::string* Player::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Player.uuid)
  return uuid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Player::release_uuid() {
  // @@protoc_insertion_point(field_release:Proto.Player.uuid)
  
  return uuid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.uuid)
}

// string account = 5;
inline void Player::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Player::account() const {
  // @@protoc_insertion_point(field_get:Proto.Player.account)
  return account_.GetNoArena();
}
inline void Player::set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Player.account)
}
inline void Player::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Player.account)
}
inline void Player::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Player.account)
}
inline void Player::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Player.account)
}
inline std::string* Player::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Player.account)
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Player::release_account() {
  // @@protoc_insertion_point(field_release:Proto.Player.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.account)
}

// bytes name = 6;
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:Proto.Player.name)
  return name_.GetNoArena();
}
inline void Player::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.Player.name)
}
inline void Player::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.Player.name)
}
inline void Player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.Player.name)
}
inline void Player::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.Player.name)
}
inline std::string* Player::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Proto.Player.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:Proto.Player.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.name)
}

// .Proto.PlayerBase base = 7;
inline bool Player::has_base() const {
  return this != internal_default_instance() && base_ != nullptr;
}
inline void Player::clear_base() {
  if (GetArenaNoVirtual() == nullptr && base_ != nullptr) {
    delete base_;
  }
  base_ = nullptr;
}
inline const ::Proto::PlayerBase& Player::base() const {
  const ::Proto::PlayerBase* p = base_;
  // @@protoc_insertion_point(field_get:Proto.Player.base)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::PlayerBase*>(
      &::Proto::_PlayerBase_default_instance_);
}
inline ::Proto::PlayerBase* Player::release_base() {
  // @@protoc_insertion_point(field_release:Proto.Player.base)
  
  ::Proto::PlayerBase* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::Proto::PlayerBase* Player::mutable_base() {
  
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::PlayerBase>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Player.base)
  return base_;
}
inline void Player::set_allocated_base(::Proto::PlayerBase* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.base)
}

// .Proto.PlayerMisc misc = 8;
inline bool Player::has_misc() const {
  return this != internal_default_instance() && misc_ != nullptr;
}
inline void Player::clear_misc() {
  if (GetArenaNoVirtual() == nullptr && misc_ != nullptr) {
    delete misc_;
  }
  misc_ = nullptr;
}
inline const ::Proto::PlayerMisc& Player::misc() const {
  const ::Proto::PlayerMisc* p = misc_;
  // @@protoc_insertion_point(field_get:Proto.Player.misc)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::PlayerMisc*>(
      &::Proto::_PlayerMisc_default_instance_);
}
inline ::Proto::PlayerMisc* Player::release_misc() {
  // @@protoc_insertion_point(field_release:Proto.Player.misc)
  
  ::Proto::PlayerMisc* temp = misc_;
  misc_ = nullptr;
  return temp;
}
inline ::Proto::PlayerMisc* Player::mutable_misc() {
  
  if (misc_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::PlayerMisc>(GetArenaNoVirtual());
    misc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Player.misc)
  return misc_;
}
inline void Player::set_allocated_misc(::Proto::PlayerMisc* misc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete misc_;
  }
  if (misc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      misc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, misc, submessage_arena);
    }
    
  } else {
    
  }
  misc_ = misc;
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.misc)
}

// .Proto.PlayerItem item = 9;
inline bool Player::has_item() const {
  return this != internal_default_instance() && item_ != nullptr;
}
inline void Player::clear_item() {
  if (GetArenaNoVirtual() == nullptr && item_ != nullptr) {
    delete item_;
  }
  item_ = nullptr;
}
inline const ::Proto::PlayerItem& Player::item() const {
  const ::Proto::PlayerItem* p = item_;
  // @@protoc_insertion_point(field_get:Proto.Player.item)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::PlayerItem*>(
      &::Proto::_PlayerItem_default_instance_);
}
inline ::Proto::PlayerItem* Player::release_item() {
  // @@protoc_insertion_point(field_release:Proto.Player.item)
  
  ::Proto::PlayerItem* temp = item_;
  item_ = nullptr;
  return temp;
}
inline ::Proto::PlayerItem* Player::mutable_item() {
  
  if (item_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::PlayerItem>(GetArenaNoVirtual());
    item_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Player.item)
  return item_;
}
inline void Player::set_allocated_item(::Proto::PlayerItem* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete item_;
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  item_ = item;
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.item)
}

// .Proto.PlayerCard card = 10;
inline bool Player::has_card() const {
  return this != internal_default_instance() && card_ != nullptr;
}
inline void Player::clear_card() {
  if (GetArenaNoVirtual() == nullptr && card_ != nullptr) {
    delete card_;
  }
  card_ = nullptr;
}
inline const ::Proto::PlayerCard& Player::card() const {
  const ::Proto::PlayerCard* p = card_;
  // @@protoc_insertion_point(field_get:Proto.Player.card)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::PlayerCard*>(
      &::Proto::_PlayerCard_default_instance_);
}
inline ::Proto::PlayerCard* Player::release_card() {
  // @@protoc_insertion_point(field_release:Proto.Player.card)
  
  ::Proto::PlayerCard* temp = card_;
  card_ = nullptr;
  return temp;
}
inline ::Proto::PlayerCard* Player::mutable_card() {
  
  if (card_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::PlayerCard>(GetArenaNoVirtual());
    card_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Player.card)
  return card_;
}
inline void Player::set_allocated_card(::Proto::PlayerCard* card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete card_;
  }
  if (card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    
  } else {
    
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.card)
}

// .Proto.PlayerCharacter character = 11;
inline bool Player::has_character() const {
  return this != internal_default_instance() && character_ != nullptr;
}
inline void Player::clear_character() {
  if (GetArenaNoVirtual() == nullptr && character_ != nullptr) {
    delete character_;
  }
  character_ = nullptr;
}
inline const ::Proto::PlayerCharacter& Player::character() const {
  const ::Proto::PlayerCharacter* p = character_;
  // @@protoc_insertion_point(field_get:Proto.Player.character)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::PlayerCharacter*>(
      &::Proto::_PlayerCharacter_default_instance_);
}
inline ::Proto::PlayerCharacter* Player::release_character() {
  // @@protoc_insertion_point(field_release:Proto.Player.character)
  
  ::Proto::PlayerCharacter* temp = character_;
  character_ = nullptr;
  return temp;
}
inline ::Proto::PlayerCharacter* Player::mutable_character() {
  
  if (character_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::PlayerCharacter>(GetArenaNoVirtual());
    character_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Player.character)
  return character_;
}
inline void Player::set_allocated_character(::Proto::PlayerCharacter* character) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete character_;
  }
  if (character) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      character = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character, submessage_arena);
    }
    
  } else {
    
  }
  character_ = character;
  // @@protoc_insertion_point(field_set_allocated:Proto.Player.character)
}

// -------------------------------------------------------------------

// Position

// .Proto.Vector3 location = 1;
inline bool Position::has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline void Position::clear_location() {
  if (GetArenaNoVirtual() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::Proto::Vector3& Position::location() const {
  const ::Proto::Vector3* p = location_;
  // @@protoc_insertion_point(field_get:Proto.Position.location)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Vector3*>(
      &::Proto::_Vector3_default_instance_);
}
inline ::Proto::Vector3* Position::release_location() {
  // @@protoc_insertion_point(field_release:Proto.Position.location)
  
  ::Proto::Vector3* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::Proto::Vector3* Position::mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Vector3>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Position.location)
  return location_;
}
inline void Position::set_allocated_location(::Proto::Vector3* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:Proto.Position.location)
}

// .Proto.Vector3 rotation = 2;
inline bool Position::has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline void Position::clear_rotation() {
  if (GetArenaNoVirtual() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::Proto::Vector3& Position::rotation() const {
  const ::Proto::Vector3* p = rotation_;
  // @@protoc_insertion_point(field_get:Proto.Position.rotation)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Vector3*>(
      &::Proto::_Vector3_default_instance_);
}
inline ::Proto::Vector3* Position::release_rotation() {
  // @@protoc_insertion_point(field_release:Proto.Position.rotation)
  
  ::Proto::Vector3* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::Proto::Vector3* Position::mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Vector3>(GetArenaNoVirtual());
    rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Position.rotation)
  return rotation_;
}
inline void Position::set_allocated_rotation(::Proto::Vector3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Proto.Position.rotation)
}

// -------------------------------------------------------------------

// NPC

// int32 id = 1;
inline void NPC::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NPC::id() const {
  // @@protoc_insertion_point(field_get:Proto.NPC.id)
  return id_;
}
inline void NPC::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.NPC.id)
}

// int64 sn = 2;
inline void NPC::clear_sn() {
  sn_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NPC::sn() const {
  // @@protoc_insertion_point(field_get:Proto.NPC.sn)
  return sn_;
}
inline void NPC::set_sn(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.NPC.sn)
}

// int64 create_time = 3;
inline void NPC::clear_create_time() {
  create_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NPC::create_time() const {
  // @@protoc_insertion_point(field_get:Proto.NPC.create_time)
  return create_time_;
}
inline void NPC::set_create_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  create_time_ = value;
  // @@protoc_insertion_point(field_set:Proto.NPC.create_time)
}

// int64 die_time = 4;
inline void NPC::clear_die_time() {
  die_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NPC::die_time() const {
  // @@protoc_insertion_point(field_get:Proto.NPC.die_time)
  return die_time_;
}
inline void NPC::set_die_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  die_time_ = value;
  // @@protoc_insertion_point(field_set:Proto.NPC.die_time)
}

// .Proto.Position init_pos = 5;
inline bool NPC::has_init_pos() const {
  return this != internal_default_instance() && init_pos_ != nullptr;
}
inline void NPC::clear_init_pos() {
  if (GetArenaNoVirtual() == nullptr && init_pos_ != nullptr) {
    delete init_pos_;
  }
  init_pos_ = nullptr;
}
inline const ::Proto::Position& NPC::init_pos() const {
  const ::Proto::Position* p = init_pos_;
  // @@protoc_insertion_point(field_get:Proto.NPC.init_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* NPC::release_init_pos() {
  // @@protoc_insertion_point(field_release:Proto.NPC.init_pos)
  
  ::Proto::Position* temp = init_pos_;
  init_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* NPC::mutable_init_pos() {
  
  if (init_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    init_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.NPC.init_pos)
  return init_pos_;
}
inline void NPC::set_allocated_init_pos(::Proto::Position* init_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete init_pos_;
  }
  if (init_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      init_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_pos, submessage_arena);
    }
    
  } else {
    
  }
  init_pos_ = init_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.NPC.init_pos)
}

// .Proto.Position cur_pos = 6;
inline bool NPC::has_cur_pos() const {
  return this != internal_default_instance() && cur_pos_ != nullptr;
}
inline void NPC::clear_cur_pos() {
  if (GetArenaNoVirtual() == nullptr && cur_pos_ != nullptr) {
    delete cur_pos_;
  }
  cur_pos_ = nullptr;
}
inline const ::Proto::Position& NPC::cur_pos() const {
  const ::Proto::Position* p = cur_pos_;
  // @@protoc_insertion_point(field_get:Proto.NPC.cur_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* NPC::release_cur_pos() {
  // @@protoc_insertion_point(field_release:Proto.NPC.cur_pos)
  
  ::Proto::Position* temp = cur_pos_;
  cur_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* NPC::mutable_cur_pos() {
  
  if (cur_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    cur_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.NPC.cur_pos)
  return cur_pos_;
}
inline void NPC::set_allocated_cur_pos(::Proto::Position* cur_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cur_pos_;
  }
  if (cur_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cur_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_pos, submessage_arena);
    }
    
  } else {
    
  }
  cur_pos_ = cur_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.NPC.cur_pos)
}

// .Proto.Position next_pos = 7;
inline bool NPC::has_next_pos() const {
  return this != internal_default_instance() && next_pos_ != nullptr;
}
inline void NPC::clear_next_pos() {
  if (GetArenaNoVirtual() == nullptr && next_pos_ != nullptr) {
    delete next_pos_;
  }
  next_pos_ = nullptr;
}
inline const ::Proto::Position& NPC::next_pos() const {
  const ::Proto::Position* p = next_pos_;
  // @@protoc_insertion_point(field_get:Proto.NPC.next_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* NPC::release_next_pos() {
  // @@protoc_insertion_point(field_release:Proto.NPC.next_pos)
  
  ::Proto::Position* temp = next_pos_;
  next_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* NPC::mutable_next_pos() {
  
  if (next_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    next_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.NPC.next_pos)
  return next_pos_;
}
inline void NPC::set_allocated_next_pos(::Proto::Position* next_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete next_pos_;
  }
  if (next_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      next_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pos, submessage_arena);
    }
    
  } else {
    
  }
  next_pos_ = next_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.NPC.next_pos)
}

// -------------------------------------------------------------------

// OBJ

// int32 id = 1;
inline void OBJ::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OBJ::id() const {
  // @@protoc_insertion_point(field_get:Proto.OBJ.id)
  return id_;
}
inline void OBJ::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:Proto.OBJ.id)
}

// int64 sn = 2;
inline void OBJ::clear_sn() {
  sn_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OBJ::sn() const {
  // @@protoc_insertion_point(field_get:Proto.OBJ.sn)
  return sn_;
}
inline void OBJ::set_sn(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sn_ = value;
  // @@protoc_insertion_point(field_set:Proto.OBJ.sn)
}

// int64 create_time = 3;
inline void OBJ::clear_create_time() {
  create_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OBJ::create_time() const {
  // @@protoc_insertion_point(field_get:Proto.OBJ.create_time)
  return create_time_;
}
inline void OBJ::set_create_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  create_time_ = value;
  // @@protoc_insertion_point(field_set:Proto.OBJ.create_time)
}

// int64 die_time = 4;
inline void OBJ::clear_die_time() {
  die_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OBJ::die_time() const {
  // @@protoc_insertion_point(field_get:Proto.OBJ.die_time)
  return die_time_;
}
inline void OBJ::set_die_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  die_time_ = value;
  // @@protoc_insertion_point(field_set:Proto.OBJ.die_time)
}

// .Proto.Position init_pos = 5;
inline bool OBJ::has_init_pos() const {
  return this != internal_default_instance() && init_pos_ != nullptr;
}
inline void OBJ::clear_init_pos() {
  if (GetArenaNoVirtual() == nullptr && init_pos_ != nullptr) {
    delete init_pos_;
  }
  init_pos_ = nullptr;
}
inline const ::Proto::Position& OBJ::init_pos() const {
  const ::Proto::Position* p = init_pos_;
  // @@protoc_insertion_point(field_get:Proto.OBJ.init_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* OBJ::release_init_pos() {
  // @@protoc_insertion_point(field_release:Proto.OBJ.init_pos)
  
  ::Proto::Position* temp = init_pos_;
  init_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* OBJ::mutable_init_pos() {
  
  if (init_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    init_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.OBJ.init_pos)
  return init_pos_;
}
inline void OBJ::set_allocated_init_pos(::Proto::Position* init_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete init_pos_;
  }
  if (init_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      init_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init_pos, submessage_arena);
    }
    
  } else {
    
  }
  init_pos_ = init_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.OBJ.init_pos)
}

// .Proto.Position cur_pos = 6;
inline bool OBJ::has_cur_pos() const {
  return this != internal_default_instance() && cur_pos_ != nullptr;
}
inline void OBJ::clear_cur_pos() {
  if (GetArenaNoVirtual() == nullptr && cur_pos_ != nullptr) {
    delete cur_pos_;
  }
  cur_pos_ = nullptr;
}
inline const ::Proto::Position& OBJ::cur_pos() const {
  const ::Proto::Position* p = cur_pos_;
  // @@protoc_insertion_point(field_get:Proto.OBJ.cur_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* OBJ::release_cur_pos() {
  // @@protoc_insertion_point(field_release:Proto.OBJ.cur_pos)
  
  ::Proto::Position* temp = cur_pos_;
  cur_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* OBJ::mutable_cur_pos() {
  
  if (cur_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    cur_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.OBJ.cur_pos)
  return cur_pos_;
}
inline void OBJ::set_allocated_cur_pos(::Proto::Position* cur_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cur_pos_;
  }
  if (cur_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cur_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_pos, submessage_arena);
    }
    
  } else {
    
  }
  cur_pos_ = cur_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.OBJ.cur_pos)
}

// .Proto.Position next_pos = 7;
inline bool OBJ::has_next_pos() const {
  return this != internal_default_instance() && next_pos_ != nullptr;
}
inline void OBJ::clear_next_pos() {
  if (GetArenaNoVirtual() == nullptr && next_pos_ != nullptr) {
    delete next_pos_;
  }
  next_pos_ = nullptr;
}
inline const ::Proto::Position& OBJ::next_pos() const {
  const ::Proto::Position* p = next_pos_;
  // @@protoc_insertion_point(field_get:Proto.OBJ.next_pos)
  return p != nullptr ? *p : *reinterpret_cast<const ::Proto::Position*>(
      &::Proto::_Position_default_instance_);
}
inline ::Proto::Position* OBJ::release_next_pos() {
  // @@protoc_insertion_point(field_release:Proto.OBJ.next_pos)
  
  ::Proto::Position* temp = next_pos_;
  next_pos_ = nullptr;
  return temp;
}
inline ::Proto::Position* OBJ::mutable_next_pos() {
  
  if (next_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Proto::Position>(GetArenaNoVirtual());
    next_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Proto.OBJ.next_pos)
  return next_pos_;
}
inline void OBJ::set_allocated_next_pos(::Proto::Position* next_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete next_pos_;
  }
  if (next_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      next_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_pos, submessage_arena);
    }
    
  } else {
    
  }
  next_pos_ = next_pos;
  // @@protoc_insertion_point(field_set_allocated:Proto.OBJ.next_pos)
}

// -------------------------------------------------------------------

// DBWorldData

// int32 server_id = 1;
inline void DBWorldData::clear_server_id() {
  server_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DBWorldData::server_id() const {
  // @@protoc_insertion_point(field_get:Proto.DBWorldData.server_id)
  return server_id_;
}
inline void DBWorldData::set_server_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.DBWorldData.server_id)
}

// int32 world_id = 2;
inline void DBWorldData::clear_world_id() {
  world_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DBWorldData::world_id() const {
  // @@protoc_insertion_point(field_get:Proto.DBWorldData.world_id)
  return world_id_;
}
inline void DBWorldData::set_world_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  world_id_ = value;
  // @@protoc_insertion_point(field_set:Proto.DBWorldData.world_id)
}

// repeated .Proto.NPC npc_list = 3;
inline int DBWorldData::npc_list_size() const {
  return npc_list_.size();
}
inline void DBWorldData::clear_npc_list() {
  npc_list_.Clear();
}
inline ::Proto::NPC* DBWorldData::mutable_npc_list(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.DBWorldData.npc_list)
  return npc_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::NPC >*
DBWorldData::mutable_npc_list() {
  // @@protoc_insertion_point(field_mutable_list:Proto.DBWorldData.npc_list)
  return &npc_list_;
}
inline const ::Proto::NPC& DBWorldData::npc_list(int index) const {
  // @@protoc_insertion_point(field_get:Proto.DBWorldData.npc_list)
  return npc_list_.Get(index);
}
inline ::Proto::NPC* DBWorldData::add_npc_list() {
  // @@protoc_insertion_point(field_add:Proto.DBWorldData.npc_list)
  return npc_list_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::NPC >&
DBWorldData::npc_list() const {
  // @@protoc_insertion_point(field_list:Proto.DBWorldData.npc_list)
  return npc_list_;
}

// repeated .Proto.OBJ obj_list = 4;
inline int DBWorldData::obj_list_size() const {
  return obj_list_.size();
}
inline void DBWorldData::clear_obj_list() {
  obj_list_.Clear();
}
inline ::Proto::OBJ* DBWorldData::mutable_obj_list(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.DBWorldData.obj_list)
  return obj_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::OBJ >*
DBWorldData::mutable_obj_list() {
  // @@protoc_insertion_point(field_mutable_list:Proto.DBWorldData.obj_list)
  return &obj_list_;
}
inline const ::Proto::OBJ& DBWorldData::obj_list(int index) const {
  // @@protoc_insertion_point(field_get:Proto.DBWorldData.obj_list)
  return obj_list_.Get(index);
}
inline ::Proto::OBJ* DBWorldData::add_obj_list() {
  // @@protoc_insertion_point(field_add:Proto.DBWorldData.obj_list)
  return obj_list_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Proto::OBJ >&
DBWorldData::obj_list() const {
  // @@protoc_insertion_point(field_list:Proto.DBWorldData.obj_list)
  return obj_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Proto::Card_CardCareerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::Card_CardCareerType>() {
  return ::Proto::Card_CardCareerType_descriptor();
}
template <> struct is_proto_enum< ::Proto::Card_CardCultivateState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::Card_CardCultivateState>() {
  return ::Proto::Card_CardCultivateState_descriptor();
}
template <> struct is_proto_enum< ::Proto::Team_TeamType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::Team_TeamType>() {
  return ::Proto::Team_TeamType_descriptor();
}
template <> struct is_proto_enum< ::Proto::Gender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::Gender>() {
  return ::Proto::Gender_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_2eproto
